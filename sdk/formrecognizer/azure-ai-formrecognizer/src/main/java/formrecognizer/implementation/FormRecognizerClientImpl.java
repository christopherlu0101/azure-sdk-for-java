// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

package formrecognizer.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.http.rest.VoidResponse;
import formrecognizer.FormRecognizerClient;
import formrecognizer.models.AnalyzeLayoutAsyncResponse;
import formrecognizer.models.AnalyzeOperationResult;
import formrecognizer.models.AnalyzeReceiptAsyncResponse;
import formrecognizer.models.AnalyzeWithCustomModelResponse;
import formrecognizer.models.ErrorResponseException;
import formrecognizer.models.Model;
import formrecognizer.models.ModelsModel;
import formrecognizer.models.TrainCustomModelAsyncResponse;
import formrecognizer.models.TrainRequest;
import java.util.UUID;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the FormRecognizerClient type.
 */
public final class FormRecognizerClientImpl implements FormRecognizerClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private FormRecognizerClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     */
    private String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Sets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @param endpoint the endpoint value.
     */
    FormRecognizerClientImpl setEndpoint(String endpoint) {
        this.endpoint = endpoint;
        return this;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     */
    public FormRecognizerClientImpl() {
        new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy()).build();
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    public FormRecognizerClientImpl(HttpPipeline httpPipeline) {
        this.httpPipeline = httpPipeline;
        this.service = RestProxy.create(FormRecognizerClientService.class, this.httpPipeline);
    }

    /**
     * The interface defining all the services for FormRecognizerClient to be
     * used by the proxy service to perform REST calls.
     */
    @Host("{endpoint}/formrecognizer/v2.0-preview")
    @ServiceInterface(name = "FormRecognizerClient")
    private interface FormRecognizerClientService {
        @Post("custom/models")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<TrainCustomModelAsyncResponse> trainCustomModelAsync(@HostParam("endpoint") String endpoint, @BodyParam("application/json; charset=utf-8") TrainRequest trainRequest);

        @Get("custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<SimpleResponse<ModelsModel>> getCustomModels(@HostParam("endpoint") String endpoint, @QueryParam("op") String op);

        @Get("custom/models/{modelId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<SimpleResponse<Model>> getCustomModel(@PathParam("modelId") UUID modelId, @HostParam("endpoint") String endpoint, @QueryParam("includeKeys") Boolean includeKeys);

        @Delete("custom/models/{modelId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<VoidResponse> deleteCustomModel(@PathParam("modelId") UUID modelId, @HostParam("endpoint") String endpoint);

        @Post("custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModel(@PathParam("modelId") UUID modelId, @HostParam("endpoint") String endpoint, @QueryParam("includeTextDetails") Boolean includeTextDetails, @BodyParam("application/json; charset=utf-8") Object fileStream);

        @Get("custom/models/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeFormResult(@PathParam("modelId") UUID modelId, @PathParam("resultId") UUID resultId, @HostParam("endpoint") String endpoint);

        @Post("prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsync(@HostParam("endpoint") String endpoint, @QueryParam("includeTextDetails") Boolean includeTextDetails, @BodyParam("application/json; charset=utf-8") Object fileStream);

        @Get("prebuilt/receipt/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeReceiptResult(@PathParam("resultId") UUID resultId, @HostParam("endpoint") String endpoint);

        @Post("layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsync(@HostParam("endpoint") String endpoint, @BodyParam("application/json; charset=utf-8") Object fileStream);

        @Get("layout/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeLayoutResult(@PathParam("resultId") UUID resultId, @HostParam("endpoint") String endpoint);
    }

    /**
     * Train Custom Model
     * Create and train a custom model. The request must include a source parameter that is either an externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be trained is expected to be under the source folder or sub folders under it. Models are trained using documents that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TrainCustomModelAsyncResponse> trainCustomModelAsyncWithRestResponseAsync(TrainRequest trainRequest) {
        return service.trainCustomModelAsync(this.getEndpoint(), trainRequest);
    }

    /**
     * Train Custom Model
     * Create and train a custom model. The request must include a source parameter that is either an externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be trained is expected to be under the source folder or sub folders under it. Models are trained using documents that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainCustomModelAsyncAsync(TrainRequest trainRequest) {
        return trainCustomModelAsyncWithRestResponseAsync(trainRequest)
            .flatMap((TrainCustomModelAsyncResponse res) -> Mono.empty());
    }

    /**
     * List Custom Models
     * Get information about all custom models.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ModelsModel>> getCustomModelsWithRestResponseAsync() {
        final String op = "full";
        return service.getCustomModels(this.getEndpoint(), op);
    }

    /**
     * List Custom Models
     * Get information about all custom models.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ModelsModel> getCustomModelsAsync() {
        return getCustomModelsWithRestResponseAsync()
            .flatMap((SimpleResponse<ModelsModel> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * List Custom Models
     * Get information about all custom models.
     *
     * @param op Specify whether to return summary or full list of models. Possible values include: 'full', 'summary'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<ModelsModel>> getCustomModelsWithRestResponseAsync(String op) {
        return service.getCustomModels(this.getEndpoint(), op);
    }

    /**
     * List Custom Models
     * Get information about all custom models.
     *
     * @param op Specify whether to return summary or full list of models. Possible values include: 'full', 'summary'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ModelsModel> getCustomModelsAsync(String op) {
        return getCustomModelsWithRestResponseAsync(op)
            .flatMap((SimpleResponse<ModelsModel> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Get Custom Model
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Model>> getCustomModelWithRestResponseAsync(UUID modelId) {
        final Boolean includeKeys = false;
        return service.getCustomModel(modelId, this.getEndpoint(), includeKeys);
    }

    /**
     * Get Custom Model
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId) {
        return getCustomModelWithRestResponseAsync(modelId)
            .flatMap((SimpleResponse<Model> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Get Custom Model
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Model>> getCustomModelWithRestResponseAsync(UUID modelId, Boolean includeKeys) {
        return service.getCustomModel(modelId, this.getEndpoint(), includeKeys);
    }

    /**
     * Get Custom Model
     * Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithRestResponseAsync(modelId, includeKeys)
            .flatMap((SimpleResponse<Model> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Delete Custom Model
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> deleteCustomModelWithRestResponseAsync(UUID modelId) {
        return service.deleteCustomModel(modelId, this.getEndpoint());
    }

    /**
     * Delete Custom Model
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId) {
        return deleteCustomModelWithRestResponseAsync(modelId)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Analyze Form
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithRestResponseAsync(UUID modelId) {
        final Boolean includeTextDetails = false;
        final Object fileStream = null;
        return service.analyzeWithCustomModel(modelId, this.getEndpoint(), includeTextDetails, fileStream);
    }

    /**
     * Analyze Form
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId) {
        return analyzeWithCustomModelWithRestResponseAsync(modelId)
            .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Analyze Form
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeWithCustomModelResponse> analyzeWithCustomModelWithRestResponseAsync(UUID modelId, Boolean includeTextDetails, Object fileStream) {
        return service.analyzeWithCustomModel(modelId, this.getEndpoint(), includeTextDetails, fileStream);
    }

    /**
     * Analyze Form
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, Boolean includeTextDetails, Object fileStream) {
        return analyzeWithCustomModelWithRestResponseAsync(modelId, includeTextDetails, fileStream)
            .flatMap((AnalyzeWithCustomModelResponse res) -> Mono.empty());
    }

    /**
     * Get Analyze Form Result
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeFormResultWithRestResponseAsync(UUID modelId, UUID resultId) {
        return service.getAnalyzeFormResult(modelId, resultId, this.getEndpoint());
    }

    /**
     * Get Analyze Form Result
     * Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithRestResponseAsync(modelId, resultId)
            .flatMap((SimpleResponse<AnalyzeOperationResult> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Analyze Receipt
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithRestResponseAsync() {
        final Boolean includeTextDetails = false;
        final Object fileStream = null;
        return service.analyzeReceiptAsync(this.getEndpoint(), includeTextDetails, fileStream);
    }

    /**
     * Analyze Receipt
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync() {
        return analyzeReceiptAsyncWithRestResponseAsync()
            .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeReceiptAsyncResponse> analyzeReceiptAsyncWithRestResponseAsync(Boolean includeTextDetails, Object fileStream) {
        return service.analyzeReceiptAsync(this.getEndpoint(), includeTextDetails, fileStream);
    }

    /**
     * Analyze Receipt
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(Boolean includeTextDetails, Object fileStream) {
        return analyzeReceiptAsyncWithRestResponseAsync(includeTextDetails, fileStream)
            .flatMap((AnalyzeReceiptAsyncResponse res) -> Mono.empty());
    }

    /**
     * Get Analyze Receipt Result
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeReceiptResultWithRestResponseAsync(UUID resultId) {
        return service.getAnalyzeReceiptResult(resultId, this.getEndpoint());
    }

    /**
     * Get Analyze Receipt Result
     * Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId) {
        return getAnalyzeReceiptResultWithRestResponseAsync(resultId)
            .flatMap((SimpleResponse<AnalyzeOperationResult> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Analyze Layout
     * Extract text and layout information from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithRestResponseAsync() {
        final Object fileStream = null;
        return service.analyzeLayoutAsync(this.getEndpoint(), fileStream);
    }

    /**
     * Analyze Layout
     * Extract text and layout information from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync() {
        return analyzeLayoutAsyncWithRestResponseAsync()
            .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Analyze Layout
     * Extract text and layout information from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeLayoutAsyncResponse> analyzeLayoutAsyncWithRestResponseAsync(Object fileStream) {
        return service.analyzeLayoutAsync(this.getEndpoint(), fileStream);
    }

    /**
     * Analyze Layout
     * Extract text and layout information from a given document. The input document must be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param fileStream .json, .pdf, .jpg, .png or .tiff type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(Object fileStream) {
        return analyzeLayoutAsyncWithRestResponseAsync(fileStream)
            .flatMap((AnalyzeLayoutAsyncResponse res) -> Mono.empty());
    }

    /**
     * Get Analyze Layout Result
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<AnalyzeOperationResult>> getAnalyzeLayoutResultWithRestResponseAsync(UUID resultId) {
        return service.getAnalyzeLayoutResult(resultId, this.getEndpoint());
    }

    /**
     * Get Analyze Layout Result
     * Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId) {
        return getAnalyzeLayoutResultWithRestResponseAsync(resultId)
            .flatMap((SimpleResponse<AnalyzeOperationResult> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }
}
